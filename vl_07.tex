\section{Das Wörterbuchproblem}

\paragraph*{Geg.} Universum $U$ (sehr groß); Teilmenge $S \subseteq U$ (mittelgroß) mit $|S|=n$; ein $m \in \mathbb{N}$

\paragraph*{Ziel} Finde: $h: U \rightarrow \{ 0,\dots,\dots m-1 \}$ sodass $\forall\ 0 \leq i \leq m\ \big| \{ x \in s | h(x)=i \} \big| \leq \frac{n}{m}$

\paragraph*{Bsp.} $U=\mathbb{N}$; $S=\{ 1,7,23,99 \}$ mit $n=4$ und $m=5$

Eine gute Funktion $h$ für $S$ wäre z.B. $h(x)=x \mod 5$, wobei $h$ die Hashfunktion ist.
\begin{table}[htb!]
\centering
\begin{tabular}{l|l}
$x$ & $h(x)$ \\ 
\hline 
1 & 1 \\ 
7 & 2 \\ 
23 & 3 \\ 
99 & 4 \\ 
\end{tabular} 
\end{table}

Die gleiche Hashfunktion ist für ein $S = \{ 12,22,17,32,52 \}$ sehr schlecht. Alle Elemente fallen in eine Kategorie.


\subsection{Anwendungsbeispiele}

\subsubsection{Telefonbuch}
\minisec{} Man möchte für Name + Vornamedie zugehörige Telefonnummer herausfinden.

\minisec{} $U \overset{\wedge}{=}$ Menge aller Zahlen die irgendeiner Name-Vorname-Kombination entsprechen.

\minisec{} $S \leq U \overset{\wedge}{=}$ Name-Vorname in Stuttgart. Mit $|n| = 500000$ und $m = 500 000$

\minisec{} Könnten wir eine Hashfunktion: $h:U \rightarrow \{ 0,\dots m-1 \}$ abbildet mit $\forall 0 \leq i < m ; \big| \{ x\in S | h(x)=i \} \big| \leq \frac{n}{m} = 1$ %TODO ; richtig

\minisec{} Das ist Toll!

\minisec{} Wir können ein Array anlegen mit 500000 Einträgen. Die Telefonnummer eines 'Name+Vorname' speichern wir an positiven $h$(Name+Vorname) des Arrays.

\subsubsection{Stowasser (Latein-Deutsch Wörterbuch)}
$U$ \dots Menge aller Wörter. $S$ \dots Menge aller lateinischen Wörter.

\subsubsection{randomisierter Closest Pair Algorithmus}
$U$ \dots Menge aller Paare $(i,j)$, $i \in \mathbb{Z}$, $j \in \mathbb{Z}$. $S$ \dots Menge der Paare $(i,j)$, für die in entsprechender Gitterzelle mindestens ein Punkt liegt.

\subsubsection{Open-Street-Map-Daten}
Basiert auf Knoten und Kanten. Anzahl der Knoten ungefähr 4-5 Milliarden. $U \dots \mathbb{N}$. $S$ \dots Menge der KnotenIDs im aktuellen Kartenausschnitt.

\minisec{} Bei guter Hashfunktion $h$ könnte man in $O(1)$ Informationen mit $S$ assoziieren/auslesen.

\subsubsection{Datenstruktur Beispiel}
Wir betrachten ein Wörterbuch als abstrakte Datenstruktur. Diese sollte folgende Operationen unterstützen:
\begin{itemize}
	\item[] S = MAKESET() \dots leeres Wörterbuch erzeugen
	\item[] insert(x,S) \dots fügt Item $x$ (Item besteht aus (k,inf)) in $S$ ein bzw. falls Item mit Schlüssel $k$ existiert, ersetze diesen.
	\marginpar{\textcolor{blue}{\scriptsize z.B. Schlüssel: Name+Vorname; Info: Tel.nr.}}
	\item[] delete(x,S) \dots löscht Item $x$ aus Wörterbuch
	\item[] lookup(k,S) \dots gibt Item $x = (k,inf)$ auf, falls vorhanden
	\marginpar{\textcolor{blue}{\scriptsize $k$ eindeutig}}
\end{itemize}


\subsection{Naive Implementierung}
\begin{enumerate}
	\item Array/Feld für die Items, Zähler für Anzahl Items in $S$.
	%TODO bild
	\begin{itemize}
		\item[] insert(x,S) \dots überprüfen ob Schlüssel von $x$ schon enthalten, falls ja, überschreiben des entsprechenden Items, falls nein, Item hinten anhängen und Zähler eins hoch. Laufzeit: $\Theta(n)$
		\item[]  delete(x,S) \dots Item finden, austauschen mit letztem Item, Zähler eins runter. Laufzeit: $\Theta(n)$
		\item[] %TODO
	\end{itemize}
\end{enumerate}
%TODO