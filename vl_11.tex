\section{Berechenbarkeit}

\para{Uns interessieren Fragestellungen der Art: Was kann man überhaupt berechnen? Was sind geeignete Rechenmodelle?}

\paragraph*{Etwas Notation} endliches Alphabet $\sum i$ oft: $\sum = \{ 0,1 \}$ Die Menge aller Würter der Länge $k$ über $\sum$ bezeichnen wir als $\sum\limits^k$, z.B. \note{kanonische oder lexikographisch Reihenfolge} $$ \{ 0,1 \}^3 = \{ 000,001,010,011,100,101,110,111 \} $$

\paragraph*{Probleme} $\overset{\wedge}{=}$ 'Aufgaben' oder 'Fragestellungen', die wir mit dem Rechner lösen/beantworten wollen.


\subsection*{Problem 1.1}
\paragraph*{Eingabe} eine binär kodierte Zahl $q \in \mathbb{N}$; $q \geq 2$

\paragraph*{Ausgabe} ein binär kodierter Primfaktor von $q$

\paragraph*{Bsp.} Eingabe: 110 (die Zahl 6); Ausgabe: 010 (die Zahl 2) oder 011 (die Zahl 3)

\note{bin() Binärkodierung}\note{$\{ 0,1 \}^*$ endliches Wort}
\para{Das Problem samt Lösungen entspricht der Relation $R \subseteq \{ 0,1 \}^* \times \{ 0,1 \}$ mit $R=\{ (x,y) \in \{ 0,1 \}^* \times \{ 0,1 \}^* | x=bin(q), y=bin(q); p,q \in \mathbb{N}, q \geq 2, p$ prim, $p$ teilt $q \}$. Relation, da für gegebene Eingabe mehrere Ergebnisse möglich sind.}


\subsection*{Problem 1.2 (Multiplikation)}
\paragraph*{Eingabe} zwei binär kodierte Zahlen $a,b \in \mathbb{N}$.
\paragraph*{Ausgabe} binär kodierte zahl $c \in \mathbb{N}$ mit $c=a \cdot b$.

\para{Um die Zahl $a$ und $b$ in der Eingabe unterscheiden zu können, führen wir ein Trennsymbol ein, also $\sum = \{ 0,1,\# \}$. Die kodierte Eingabe ist dann $bin(a)\#bin(b)$ die kodierte Ausgabe ist $f(bin(a)\#bin(b))=bin(c)$}

\para{Wir werden uns im folgenden meistens mit Ja/Nein-Fragen beschäftigen, sogenannte Entscheidungsprobleme. Diese haben die Form $$ f:\sum\limits^* \rightarrow \{ 0,1 \} $$ wobei wir '0' als NEIN interpretieren, '1' als JA. $ L=f^{-1}(1) \subseteq \sum^* $ \dots Menge der Eingaben, die mit 1 beantwortet werden. $L$ nennen wir auch eine Sprache.}

\subsection*{Problem 1.3 (Graphzusammenhang)}
\paragraph*{Eingabe} Kodierung eines Graphen $G(V,E)$ (gerichtet).
\paragraph*{Ausgabe} Das Zeichen 1, falls $G$ zusammenhängend, ansonsten 0. Graphen könnte man kodieren als $$ \underbrace{bin(n)}_{\# Knoten = |V|}\# \underbrace{010 \dots}_{\substack{|V| \cdot |V| \text{ bits entsprechend} \\ \text{der Adjazenzmatrix von } G} } $$ %TODO matrix

\para{Es sind natürlich nicht alle Wörter über $\sum\limits^*$ eine gültige Kodierung eines Graphen. Sei $\mathcal{G}$ die Menge aller Graphen, $\mathcal{G}_z \subseteq \mathcal{G}$ die Menge aller zusammenhängenden Graphen, und $code(G)$ für $G \in \mathcal{G}$ die Kodierung eines Graphen. Dann ist die entsprechende Sprache $$ L=\{ w \in \{ 0,1,\# \}^* | \exists G(V,E) \in \mathcal{G}_z, w=code(G) \} $$ Die Sprache $L$ enthält alle Eingaben, die einen zusammenhängenden Graphen kodieren.}

\para{Das Komplement von $L$ ist definiert als $$ \overline{L} := \sum\limits^* \textbackslash L $$ $\overline{L}$ enthält Eingaben, die keiner korrekten Kodierung eines Graphen entsprechen oder Graphen, welche nicht zusammenhängend sind.}


\section{Rechnermodelle}

\subsection{Turingmaschine (TM)}
Eine Turingmaschine arbeitet auf einem beidseitig unendlichen Speicherband, %TODO bild
welches aus Zellen besteht. Jede Zelle enthält ein Element des sogenannten Bandalphabets $\Gamma$, z.B. $\Gamma=\{ 0,1,B \}$. Des Weiteren hat eine Turingmaschine einen Schreib-/Lesekopf, der über das Band wandern kann und jeweils den Inhalt der Zelle, über der er steht, lesen und schreiben kann. Daneben besitzt eine Turingmaschine auch noch eine Zustand $q \in Q$ aus einer endlichen Zustandsmenge $Q$.

\para{Per Konvention befindet sich TM am Anfang einer Rechnung im Anfangszustand $q_0 \in Q$, auf dem Band steht -- startend mit der Zelle, auf die der Schreib-/Lesekopf zeigt -- von links nach rechts die Eingabe, alle anderen Zellen enthalten das Leerzeichen ($B$).}

\para{Das Eingabealphabet $\sum \subseteq \Gamma \backslash \{B\}$. Die Arbeitsweise der Turingmaschine wird durch eine Übergangsrelation: $$ \delta : (Q \backslash \{ \overline{q}\} \times \Gamma \times Q \times \Delta \times \{ R,L,N \}) $$ ausgedrückt. Hierbei ist $\overline{q} \in Q$ ein besonderer Zustand, der Stoppzustand.}
\begin{itemize}
	\item[] $Q \backslash \{ \overline{q}\}$: Zustand
	\item[] $\Gamma$: gelesenes Zeichen / zu schreibendes Zeichen
	\item[] $Q$: neuer Zustand
	\item[] $\{ R,L,N \}$: Kopfbewegung
\end{itemize}

\para{Falls für geg. Zustand und Zeichen unter dem Schreib-/Lesekopf nur eine Aktion möglich ist, reden wir von einer Übergangsfunktion. $$ \delta : (Q \backslash \{ \overline{q}\}) \times \Gamma \rightarrow Q \times \Gamma \times \{R,L,N\} $$ $\delta(q,a)=(q',a',d)$ bedeutet: wenn die Turingmaschine im Zustand $q$ Zeichen $a'$ an diese Stelle, bewege Kopf nach $s \in \{L,R,N\}$ und nimm Zustand $a'$ ein.} %TODO satz verbessern

\para{Eine Turingmaschine führt so lange Rechenschritte aus, bis Stoppzustand $\overline{q}$ erreicht wird.}

\paragraph*{Bsp.} Übergangsfunktion $\delta$ %TODO tabelle

\paragraph*{Zusammenfassung} Eine Turingmaschine wird definiert durch
\begin{itemize}
	\item endliche Zustandsmenge $Q$
	\item endliches Eingabealphabet $\sum \supseteq \{ 0,1 \}$
	\item endliches Bandalphabet $\Gamma \supset \sum$
	\item $B \in \Gamma\backslash\sum$ (Leerzeichen)
	\item $q_0 \in Q$ (Anfangszeichen)
	\item $\overline{q} \in Q$ (Stoppzustand)
	\item Übergangsfunktion $\delta : (Q \backslash \{ \overline{q} \}) \times \Gamma \rightarrow Q \times \Gamma \times \{ R,L,N \}$
\end{itemize}

\para{Eine Turingmaschine ist also durch ein 7-Tupel ($Q,\sum,\Gamma,B,q_0,\overline{q},\delta$) definiert. Eine Konfiguration einer Turingmaschine ist ein Schnappschuss den Rechnung, zu einem bestimmten Zeitpunkt und beschreibt vollständig alle Details, die notwendig sind, um die Rechnung fortzusetzen, d.h. Bandinhalt, Zustand, Kopfposition. Formel:}
\begin{itemize}
	\item Konfiguration ist ein String $\alpha q \beta$ mit $q \in Q$, $\alpha,\beta \in \gamma^*$ welche bedeutet, dass auf Band $\alpha\beta$ steht (eingerahmt von Blanks), Zustand $q$ ist und LS-Kopf auf erstem Zeichen von $B$ steht.
	\item $\alpha'q'\beta'$, ist direkte Nachfolgeonfiguration $\alpha q \beta$, falls $\alpha'q'\beta'$ in einem Rechenschritt aus $\alpha q \beta$ entsteht, wir schreiben $\alpha q \beta \vdash \alpha'q'\beta'$.
	\item $\alpha''q''\beta''$ ist Nachfolgekonfiguration von $\alpha'q'\beta'$, falls $\alpha''q''\beta''$ in endlich vielen Rechenschritten aus $\alpha q \beta$ entspricht. Wir schreiben $\alpha q \beta \vdash^* \alpha''q''\beta''$.
\end{itemize}

\para{Die Rechnung terminiert sobald der Stoppzustand $\overline{q}$ erreicht ist. Dann gibt es keine Nachfolgekonfiguration. Die Laufzeit einer TM-Rechnung ist Zahl der Rechenschritte, die Turingmaschine bis zur Terminierung ausführt. Falls die Rechnung nicht terminiert, ist Laufzeit unbeschränkt. Der Platzverbrauch einer TM-Rechnung ist die Anzahl besuchter Bandzellen (kann auch unbeschränkt sein).}

\section{TM-berechenbare Funktionen und Sprachen}
Eine Turingmaschine $M$, die für jede Eingabe terminiert, berechnet eine totale Funktion $f_M:\sum^* \rightarrow \sum^*$. Wenn der Stoppzustand $\overline{q}$ erreicht ist, kann das Ergebnis $f_M(x)$ rechts vom LS-Kopf vom Band gelesen werden (bis zum ersten Zeichen nicht in $\sum$). Das Ergebnis kann auch $E$\footnote{leeres Wort} sein, falls LS-Kopf nach Beendung auf ein Zeichen nicht aus $\sum$ ist. Manche Turingmaschinen terminieren nicht, wir erweitern deshalb die Funktion $f_M$ wie folgt: $$ f_M:\sum\limits^* \rightarrow \sum\limits^* \cup \{ \perp \} $$ $'\perp'$ (Bottom) steht für 'nicht definiert', d.h. wenn $M$ auf die Eingabe nicht terminiert.

\paragraph*{Def.} Eine Funktion $f:\sum\limits^* \rightarrow \sum\limits^* \cup \{ \perp \}$ heißt TM-berechenbar (rekursiv), wenn es eine Turingmaschine $M$ gibt, mit $f=f_M$.